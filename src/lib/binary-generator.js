/**
 * Binary Generator Utility
 *
 * Generates custom binary files for projects
 */

import { writeFileSync, chmodSync, existsSync, mkdirSync, readFileSync } from 'fs';
import { join, relative } from 'path';

/**
 * Generate a custom binary file for the project
 *
 * @param {string} projectRoot - Root directory of the project
 * @param {string} binaryName - Name for the binary (e.g., 'scrybe')
 * @param {string} packagePath - Path to the dev-cli package (optional, for local dev)
 * @returns {string} Path to the generated binary
 */
export function generateBinary(projectRoot, binaryName, packagePath = null) {
  // Create binary at project root without extension (like ./artisan)
  const binaryPath = join(projectRoot, binaryName);

  // Determine import path (use relative path for local dev, package name for installed)
  let importPath = '@artifex/dev-cli';
  if (packagePath && existsSync(join(packagePath, 'package.json'))) {
    // Check if we're in local development (package not installed in node_modules)
    const nodeModulesPath = join(projectRoot, 'node_modules', '@artifex', 'dev-cli');
    if (!existsSync(nodeModulesPath) && packagePath !== projectRoot) {
      // Calculate relative path from project root to package
      importPath = relative(projectRoot, join(packagePath, 'src', 'index.js'));
      if (!importPath.startsWith('.')) {
        importPath = './' + importPath;
      }
    }
  }

  // Binary template that forwards to dev-cli
  const binaryContent = `#!/usr/bin/env node

/**
 * ${binaryName} - Custom CLI Binary
 *
 * Generated by @artifex/dev-cli
 * This binary forwards all commands to the dev-cli package
 */

import { runCLI } from '${importPath}';

// Parse CLI flags
const args = process.argv.slice(2);
const options = {
  debug: process.env.DEBUG === '1' || args.includes('--debug'),
  verbose: args.includes('--verbose') || args.includes('-v'),
};

// Run CLI
runCLI(process.argv, options).catch((error) => {
  console.error('Fatal error:', error.message);
  if (options.debug) {
    console.error(error.stack);
  }
  process.exit(1);
});
`;

  // Write the binary file
  writeFileSync(binaryPath, binaryContent, 'utf8');

  // Make it executable
  try {
    chmodSync(binaryPath, '755');
  } catch (error) {
    console.warn('Warning: Could not make binary executable:', error.message);
  }

  return binaryPath;
}

/**
 * Update package.json to add custom script
 *
 * @param {string} projectRoot - Root directory of the project
 * @param {string} scriptName - Name for the npm script
 * @param {string} binaryPath - Path to the binary (absolute path)
 * @returns {boolean} Success
 */
export function addNpmScript(projectRoot, scriptName, binaryPath) {
  const packageJsonPath = join(projectRoot, 'package.json');

  if (!existsSync(packageJsonPath)) {
    return false;
  }

  try {
    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));

    // Initialize scripts if it doesn't exist
    if (!packageJson.scripts) {
      packageJson.scripts = {};
    }

    // Add the script (just the binary name since it's at project root)
    packageJson.scripts[scriptName] = `./${scriptName}`;

    // Write back to package.json with formatting
    writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n', 'utf8');

    return true;
  } catch (error) {
    console.warn('Warning: Could not update package.json:', error.message);
    return false;
  }
}
